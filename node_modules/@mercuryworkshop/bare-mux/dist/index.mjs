const e=20,t=globalThis.fetch,s=globalThis.WebSocket,r=globalThis.Request,o=globalThis.Response,a=globalThis.SharedWorker,n=globalThis.localStorage,i=globalThis.navigator.serviceWorker,c={prototype:{send:s.prototype.send},CLOSED:s.CLOSED,CLOSING:s.CLOSING,CONNECTING:s.CONNECTING,OPEN:s.OPEN};async function h(){const e=(await self.clients.matchAll({type:"window",includeUncontrolled:!0})).map((async e=>{const t=await function(e){let t=new MessageChannel;return new Promise((s=>{e.postMessage({type:"getPort",port:t.port2},[t.port2]),t.port1.onmessage=e=>{s(e.data)}}))}(e);return await l(t),t})),t=Promise.race([Promise.any(e),new Promise(((e,t)=>setTimeout(t,1e3,new TypeError("timeout"))))]);try{return await t}catch(e){if(e instanceof AggregateError)throw console.error("bare-mux: failed to get a bare-mux SharedWorker MessagePort as all clients returned an invalid MessagePort."),new Error("All clients returned an invalid MessagePort.");return console.warn("bare-mux: failed to get a bare-mux SharedWorker MessagePort within 1s, retrying"),await h()}}function l(e){const t=new MessageChannel,s=new Promise(((e,s)=>{t.port1.onmessage=t=>{"pong"===t.data.type&&e()},setTimeout(s,1500)}));return e.postMessage({message:{type:"ping"},port:t.port2},[t.port2]),s}function p(e,t){const s=new a(e,"bare-mux-worker");return t&&i.addEventListener("message",(t=>{if("getPort"===t.data.type&&t.data.port){console.debug("bare-mux: recieved request for port from sw");const s=new a(e,"bare-mux-worker");t.data.port.postMessage(s.port,[s.port])}})),s.port}let d=null;function w(){if(null===d){const e=new MessageChannel,t=new ReadableStream;let s;try{e.port1.postMessage(t,[t]),s=!0}catch(e){s=!1}return d=s,s}return d}class u{constructor(e){this.channel=new BroadcastChannel("bare-mux"),e instanceof MessagePort||e instanceof Promise?this.port=e:this.createChannel(e,!0)}createChannel(e,t){if(self.clients)this.port=h(),this.channel.onmessage=e=>{"refreshPort"===e.data.type&&(this.port=h())};else if(e&&a){if(!e.startsWith("/")&&!e.includes("://"))throw new Error("Invalid URL. Must be absolute or start at the root.");this.port=p(e,t),console.debug("bare-mux: setting localStorage bare-mux-path to",e),n["bare-mux-path"]=e}else{if(!a)throw new Error("Unable to get a channel to the SharedWorker.");{const e=n["bare-mux-path"];if(console.debug("bare-mux: got localStorage bare-mux-path:",e),!e)throw new Error("Unable to get bare-mux workerPath from localStorage.");this.port=p(e,t)}}}async sendMessage(e,t){this.port instanceof Promise&&(this.port=await this.port);try{await l(this.port)}catch{return console.warn("bare-mux: Failed to get a ping response from the worker within 1.5s. Assuming port is dead."),this.createChannel(),await this.sendMessage(e,t)}const s=new MessageChannel,r=[s.port2,...t||[]],o=new Promise(((e,t)=>{s.port1.onmessage=s=>{const r=s.data;"error"===r.type?t(r.error):e(r)}}));return this.port.postMessage({message:e,port:s.port2},r),await o}}class g extends EventTarget{constructor(e,t=[],s,r,o){super(),this.protocols=[],this.readyState=c.CONNECTING,this.binaryType="blob",this.onopen=null,this.onerror=null,this.onmessage=null,this.onclose=null,this.url=e.toString(),this.protocols=t;const a=e=>{this.readyState=c.OPEN,this.protocols=e,this.meta={headers:{"sec-websocket-protocol":e}};const t=new Event("open");this.dispatchEvent(t),this.onopen&&this.onopen(t)},n=async e=>{"string"==typeof e||("byteLength"in e?"blob"===this.binaryType?e=new Blob([e]):Object.setPrototypeOf(e,o):"arrayBuffer"in e&&"arraybuffer"===this.binaryType&&(e=await e.arrayBuffer(),Object.setPrototypeOf(e,o)));const t=new MessageEvent("message",{data:e});this.dispatchEvent(t),this.onmessage&&this.onmessage(t)},i=(e,t)=>{this.readyState=c.CLOSED;const s=new CloseEvent("close",{code:e,reason:t});this.dispatchEvent(s),this.onclose&&this.onclose(s)},h=()=>{this.readyState=c.CLOSED;const e=new Event("error");this.dispatchEvent(e),this.onerror&&this.onerror(e)};this.channel=new MessageChannel,this.channel.port1.onmessage=e=>{"open"===e.data.type?a(e.data.args[0]):"message"===e.data.type?n(e.data.args[0]):"close"===e.data.type?i(e.data.args[0],e.data.args[1]):"error"===e.data.type&&h()},s.sendMessage({type:"websocket",websocket:{url:e.toString(),origin:origin,protocols:t,requestHeaders:r,channel:this.channel.port2}},[this.channel.port2])}send(...e){if(this.readyState===c.CONNECTING)throw new DOMException("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.");let t=e[0];t.buffer&&(t=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)),this.channel.port1.postMessage({type:"data",data:t},t instanceof ArrayBuffer?[t]:[])}close(e,t){this.readyState=c.CLOSING,this.channel.port1.postMessage({type:"close",closeCode:e,closeReason:t})}get bufferedAmount(){return 0}get protocol(){return Array.isArray(this.protocols)?this.protocols[0]||"":this.protocols||""}get extensions(){return""}}function y(e,t,s){console.error(`error while processing '${s}': `,t),e.postMessage({type:"error",error:t})}g.prototype.CONNECTING=c.CONNECTING,g.prototype.OPEN=c.OPEN,g.prototype.CLOSING=c.CLOSING,g.prototype.CLOSED=c.CLOSED;function f(e){for(let t=0;t<e.length;t++){const s=e[t];if(!"!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~".includes(s))return!1}return!0}const b=["ws:","wss:"],m=[101,204,205,304],E=[301,302,303,307,308];class M{constructor(e){this.worker=new u(e)}async getTransport(){return(await this.worker.sendMessage({type:"get"})).name}async setTransport(e,t,s){await this.setManualTransport(`\n\t\t\tconst { default: BareTransport } = await import("${e}");\n\t\t\treturn [BareTransport, "${e}"];\n\t\t`,t,s)}async setManualTransport(e,t,s){if("bare-mux-remote"===e)throw new Error("Use setRemoteTransport.");await this.worker.sendMessage({type:"set",client:{function:e,args:t}},s)}async setRemoteTransport(e,t){const s=new MessageChannel;s.port1.onmessage=async t=>{const s=t.data.port,r=t.data.message;if("fetch"===r.type)try{e.ready||await e.init(),await async function(e,t,s){const r=await s.request(new URL(e.fetch.remote),e.fetch.method,e.fetch.body,e.fetch.headers,null);if(!w()&&r.body instanceof ReadableStream){const e=new o(r.body);r.body=await e.arrayBuffer()}r.body instanceof ReadableStream||r.body instanceof ArrayBuffer?t.postMessage({type:"fetch",fetch:r},[r.body]):t.postMessage({type:"fetch",fetch:r})}(r,s,e)}catch(e){y(s,e,"fetch")}else if("websocket"===r.type)try{e.ready||await e.init(),await async function(e,t,s){const[r,o]=s.connect(new URL(e.websocket.url),e.websocket.origin,e.websocket.protocols,e.websocket.requestHeaders,(t=>{e.websocket.channel.postMessage({type:"open",args:[t]})}),(t=>{t instanceof ArrayBuffer?e.websocket.channel.postMessage({type:"message",args:[t]},[t]):e.websocket.channel.postMessage({type:"message",args:[t]})}),((t,s)=>{e.websocket.channel.postMessage({type:"close",args:[t,s]})}),(t=>{e.websocket.channel.postMessage({type:"error",args:[t]})}));e.websocket.channel.onmessage=e=>{"data"===e.data.type?r(e.data.data):"close"===e.data.type&&o(e.data.closeCode,e.data.closeReason)},t.postMessage({type:"websocket"})}(r,s,e)}catch(e){y(s,e,"websocket")}},await this.worker.sendMessage({type:"set",client:{function:"bare-mux-remote",args:[s.port2,t]}},[s.port2])}getInnerPort(){return this.worker.port}}class C{constructor(e){this.worker=new u(e)}createWebSocket(e,t=[],r,o,a){try{e=new URL(e)}catch(t){throw new DOMException(`Faiiled to construct 'WebSocket': The URL '${e}' is invalid.`)}if(!b.includes(e.protocol))throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${e.protocol}' is not allowed.`);Array.isArray(t)||(t=[t]),t=t.map(String);for(const e of t)if(!f(e))throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${e}' is invalid.`);a=a||(r||s).constructor.constructor("return ArrayBuffer")().prototype,(o=o||{}).Host=new URL(e).host,o.Pragma="no-cache",o["Cache-Control"]="no-cache",o.Upgrade="websocket",o.Connection="Upgrade";return new g(e,t,this.worker,o,a)}async fetch(e,s){const a=new r(e,s),n=s?.headers||a.headers,i=n instanceof Headers?Object.fromEntries(n):n,c=a.body;let h=new URL(a.url);if(h.protocol.startsWith("blob:")){const e=await t(h),s=new o(e.body,e);return s.rawHeaders=Object.fromEntries(e.headers),s.rawResponse=e,s}for(let e=0;;e++){"host"in i?i.host=h.host:i.Host=h.host;let t=(await this.worker.sendMessage({type:"fetch",fetch:{remote:h.toString(),method:a.method,headers:i,body:c||void 0}},c?[c]:[])).fetch,r=new o(m.includes(t.status)?void 0:t.body,{headers:new Headers(t.headers),status:t.status,statusText:t.statusText});r.rawHeaders=t.headers,r.rawResponse=new o(t.body),r.finalURL=h.toString();const n=s?.redirect||a.redirect;if(!E.includes(r.status))return r;switch(n){case"follow":{const t=r.headers.get("location");if(20>e&&null!==t){h=new URL(t,h);continue}throw new TypeError("Failed to fetch")}case"error":throw new TypeError("Failed to fetch");case"manual":return r}}}}export{C as BareClient,M as BareMuxConnection,c as WebSocketFields,u as WorkerConnection,w as browserSupportsTransferringStreams,C as default,e as maxRedirects,f as validProtocol};
//# sourceMappingURL=index.mjs.map
