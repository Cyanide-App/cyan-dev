{
  "version": 3,
  "sources": ["../src/bundle/rewrite/srcset.ts", "../src/client/patch.ts", "../src/client/dom.ts", "../src/client/apis/css.ts", "../src/client/apis/location.ts", "../src/bundle/rewrite/headers.ts", "../src/client/rewrite.ts", "../src/client/apis/requests.ts", "../src/client/apis/workers.ts", "../src/client/apis/eventlistener.ts", "../src/client/apis/history.ts", "../node_modules/.pnpm/@mercuryworkshop+bare-mux@2.0.2/node_modules/@mercuryworkshop/bare-mux/dist/index.mjs", "../src/client/apis/ws.ts", "../src/client/apis/navigator.ts", "../src/client/apis/storage.ts", "../src/client/index.ts"],
  "sourcesContent": ["export function rewriteSrcset(srcset: string, origin: URL) {\n  return srcset\n    .split(', ')\n    .map((set) => {\n      return set\n        .split(' ')\n        .map((url, index) => {\n          return index === 0\n            ? self.$meteor.rewrite.url.encode(url, origin)\n            : url\n        })\n        .join(' ')\n    })\n    .join(', ')\n}\n", "// biome-ignore lint: types\ntype FunctionPatch = (...args: any[]) => any\n// biome-ignore lint: types\ntype ConstructorPatch = new (...args: any[]) => any\n// biome-ignore lint: types\ntype Arguments<T extends any[]> = (args: T) => T\n\nexport function patchFunction<T extends FunctionPatch>(\n  target: T,\n  proxy: Arguments<Parameters<T>>\n): T {\n  return new Proxy(target, {\n    apply(target: T, thisArg: unknown, argArray: Parameters<T>): ReturnType<T> {\n      const proxiedArgs = proxy(argArray)\n      return Reflect.apply(target, thisArg, proxiedArgs)\n    }\n  }) as T\n}\n\nexport function patchConstructor<T extends ConstructorPatch>(\n  target: T,\n  proxy: Arguments<ConstructorParameters<T>>\n): T {\n  return new Proxy(target, {\n    construct(\n      target: T,\n      argArray: ConstructorParameters<T>,\n      newTarget: T\n    ): InstanceType<T> {\n      const proxiedArgs = proxy(argArray)\n      return Reflect.construct(target, proxiedArgs, newTarget)\n    }\n  }) as T\n}\n", "import { rewriteSrcset } from '@/bundle/rewrite/srcset'\nimport { patchFunction } from './patch'\n\n// todo: add more attrs and clean up\nconst urlAttributes: Record<\n  string,\n  (new (\n    ...args: unknown[]\n  ) => HTMLElement)[]\n> = {\n  src: [\n    HTMLScriptElement,\n    HTMLMediaElement,\n    HTMLImageElement,\n    HTMLIFrameElement,\n    HTMLSourceElement\n  ],\n  href: [HTMLAnchorElement, HTMLLinkElement],\n  action: [HTMLFormElement],\n  formaction: [HTMLInputElement],\n  data: [HTMLObjectElement]\n}\n\nconst cspAttrs = ['nonce', 'integrity', 'csp']\n\nfor (const [attr, elms] of Object.entries(urlAttributes)) {\n  for (const elm of elms) {\n    const descriptors = Object.getOwnPropertyDescriptor(elm.prototype, attr)\n    Object.defineProperty(elm.prototype, attr, {\n      get() {\n        return self.$meteor.rewrite.url.decode(descriptors.get.call(this))\n      },\n      set(value) {\n        value = self.$meteor.rewrite.url.encode(\n          value,\n          new URL(self.$location.origin)\n        )\n        descriptors.set.call(this, value)\n      }\n    })\n  }\n}\n\nconst innerHTMLDescriptor = Object.getOwnPropertyDescriptor(\n  Element.prototype,\n  'innerHTML'\n)\n\nObject.defineProperty(Element.prototype, 'innerHTML', {\n  set(value) {\n    if (this instanceof HTMLScriptElement) {\n      value = self.$meteor.rewrite.js(value, new URL(self.$location.origin))\n    } else if (this instanceof HTMLStyleElement) {\n      value = self.$meteor.rewrite.css(value, new URL(self.$location.origin))\n    }\n\n    return innerHTMLDescriptor.set.call(this, value)\n  }\n})\n\nconst srcSetDescriptor = Object.getOwnPropertyDescriptor(\n  HTMLImageElement.prototype,\n  'srcset'\n)\n\nObject.defineProperty(HTMLImageElement.prototype, 'srcset', {\n  get() {\n    return srcSetDescriptor.get.call(this)\n  },\n  set(value) {\n    value = rewriteSrcset(value, new URL(self.$location.origin))\n    srcSetDescriptor.set.call(this, value)\n  }\n})\n\nElement.prototype.getAttribute = patchFunction(\n  Element.prototype.getAttribute,\n  ([attr]) => {\n    if (cspAttrs.includes(attr)) {\n      return null\n    }\n    return [attr]\n  }\n)\n\nElement.prototype.setAttribute = patchFunction(\n  Element.prototype.setAttribute,\n  ([attr, value]) => {\n    if (cspAttrs.includes(attr)) {\n      return [attr, '']\n    }\n    if (urlAttributes[attr]) {\n      value = self.$meteor.rewrite.url.encode(\n        value,\n        new URL(self.$location.origin)\n      )\n    }\n    if (attr === 'style') {\n      value = self.$meteor.rewrite.css(value, new URL(self.$location.origin))\n    }\n    if (attr.includes('srcset')) {\n      value = rewriteSrcset(value, new URL(self.$location.origin))\n    }\n    return [attr, value]\n  }\n)\n", "import { patchFunction } from '../patch'\nconst urlProps = [\n  'background',\n  'background-image',\n  'mask',\n  'mask-image',\n  'list-style',\n  'list-style-image',\n  'border-image',\n  'border-image-source',\n  'cursor'\n]\nCSSStyleDeclaration.prototype.setProperty = patchFunction(\n  CSSStyleDeclaration.prototype.setProperty,\n  ([prop, value, ...rest]) => {\n    if (urlProps.includes(prop)) {\n      value = self.$meteor.rewrite.css(value, new URL(self.$location.origin))\n    }\n    return [prop, value, ...rest]\n  }\n)\n", "window.$location = Object.create(window.location)\nObject.defineProperties(window.$location, {\n  toString: {\n    value() {\n      return self.$meteor.util.createOrigin().toString()\n    }\n  },\n  href: {\n    get() {\n      // let url = new URL(location.href).toString()\n      // if (url.includes(location.origin)) {\n      //   url = url.split(location.origin).join(location.origin)\n      // }\n      // return url\n      return self.$meteor.util.createOrigin().href\n    },\n    set(value) {\n      self.$meteor.rewrite.url.encode(value, self.$meteor.util.createOrigin())\n    }\n  },\n  origin: {\n    get() {\n      return self.$meteor.util.createOrigin().origin\n    }\n  },\n  search: {\n    get() {\n      return self.$meteor.util.createOrigin().search\n    },\n    set(value) {\n      window.location.search = self.$meteor.config.codec.encode(value)\n    }\n  },\n  hash: {\n    get() {\n      return self.$meteor.util.createOrigin().hash\n    }\n  },\n  pathname: {\n    get() {\n      return self.$meteor.util.createOrigin().pathname\n    },\n    set(value) {\n      const url = self.$meteor.util.createOrigin()\n      url.pathname = value\n      window.location.pathname = self.$meteor.rewrite.url.encode(\n        url.toString(),\n        url\n      )\n    }\n  },\n  protocol: {\n    get() {\n      return self.$meteor.util.createOrigin().protocol\n    },\n    set() {}\n  },\n  host: {\n    get() {\n      return self.$meteor.util.createOrigin().host\n    },\n    set(value) {\n      const url = self.$meteor.util.createOrigin()\n      url.host = value\n      window.location.host = self.$meteor.rewrite.url.encode(\n        url.toString(),\n        url\n      )\n    }\n  },\n  hostname: {\n    get() {\n      return self.$meteor.util.createOrigin().hostname\n    },\n    set(value) {\n      const url = self.$meteor.util.createOrigin()\n      url.hostname = value\n      window.location.hostname = self.$meteor.rewrite.url.encode(\n        url.toString(),\n        url\n      )\n    }\n  },\n  port: {\n    get() {\n      return self.$meteor.util.createOrigin().port\n    },\n    set() {}\n  },\n  replace: {\n    value(url: string) {\n      location.replace(\n        self.$meteor.rewrite.url.encode(url, self.$meteor.util.createOrigin())\n      )\n    }\n  }\n})\nglobalThis.$location = window.$location\ndocument.$location = window.$location\n", "const tobeDeleted = [\n  'cross-origin-embedder-policy',\n  'cross-origin-opener-policy',\n  'cross-origin-resource-policy',\n  'content-security-policy',\n  'content-security-policy-report-only',\n  'expect-ct',\n  'feature-policy',\n  'origin-isolation',\n  'strict-transport-security',\n  'upgrade-insecure-requests',\n  'x-content-type-options',\n  'x-download-options',\n  'x-frame-options',\n  'x-permitted-cross-domain-policies',\n  'x-powered-by',\n  'x-xss-protection',\n  'clear-site-data'\n]\n\nconst directRewrites = ['host', 'origin']\n\nexport function rewriteHeaders(\n  headers: Headers,\n  origin: URL,\n  HeadersInstance = Headers\n) {\n  const newHeaders = new HeadersInstance()\n  // @ts-expect-error this property does exist however\n  for (const [key, value] of headers.entries()) {\n    newHeaders.set(key.toLowerCase(), value)\n  }\n  for (const header of tobeDeleted) newHeaders.delete(header)\n\n  for (const header of ['referer', 'location', 'content-location'])\n    newHeaders.set(\n      header,\n      self.$meteor.rewrite.url.encode(newHeaders.get(header), origin)\n    )\n\n  for (const header of directRewrites) {\n    if (newHeaders.has(header)) {\n      newHeaders.set(\n        header,\n        new URL(\n          self.$meteor.rewrite.url.encode(newHeaders.get(header), origin)\n        )[header]\n      )\n    }\n  }\n  if (newHeaders.has('link')) {\n    newHeaders.set(\n      'link',\n      newHeaders\n        .get('link')\n        .replace(/<(.*?)>/gi, (match) =>\n          self.$meteor.rewrite.url.encode(match, origin)\n        )\n    )\n  }\n\n  return newHeaders\n}\n", "export function rewriteStringOrUrl(input: string | URL, origin?: URL) {\n  if (!origin) {\n    origin = self.$meteor.util.createOrigin()\n  }\n\n  if (input instanceof URL) {\n    return new URL(\n      self.$meteor.rewrite.url.encode(\n        input.toString(),\n        self.$meteor.util.createOrigin()\n      )\n    )\n  }\n\n  return self.$meteor.rewrite.url.encode(\n    input,\n    self.$meteor.util.createOrigin()\n  )\n}\n", "import { rewriteHeaders } from '@/bundle/rewrite/headers'\nimport { patchConstructor, patchFunction } from '../patch'\nimport { rewriteStringOrUrl } from '../rewrite'\nconst OldHeaders = globalThis.Headers\nwindow.fetch = patchFunction(window.fetch, (args) => {\n  if (args[0] instanceof Request) {\n    const request = args[0]\n    args[0] = new Request(\n      self.$meteor.rewrite.url.encode(\n        request.url,\n        self.$meteor.util.createOrigin()\n      ),\n      Object.defineProperty(request, 'url', { value: undefined })\n    )\n  } else {\n    args[0] = rewriteStringOrUrl(args[0])\n  }\n\n  return args\n})\n\nwindow.XMLHttpRequest.prototype.open = patchFunction(\n  XMLHttpRequest.prototype.open,\n  (args) => {\n    if (args[1] instanceof URL) {\n      args[1] = new URL(\n        self.$meteor.rewrite.url.encode(\n          args[1].href,\n          self.$meteor.util.createOrigin()\n        )\n      )\n    } else {\n      args[1] = self.$meteor.rewrite.url.encode(\n        args[1],\n        self.$meteor.util.createOrigin()\n      )\n    }\n\n    return args\n  }\n)\n\nwindow.Request = patchConstructor(Request, (args) => {\n  if (args[0] instanceof Request) {\n    const request = args[0]\n    args[0] = new Request(\n      self.$meteor.rewrite.url.encode(\n        request.url,\n        self.$meteor.util.createOrigin()\n      ),\n      Object.defineProperty(request, 'url', { value: undefined })\n    )\n  } else {\n    args[0] = rewriteStringOrUrl(args[0])\n  }\n  return args\n})\nwindow.Headers = patchConstructor(Headers, ([arg]) => {\n  arg = rewriteHeaders(\n    new OldHeaders(arg),\n    self.$meteor.util.createOrigin(),\n    OldHeaders\n  )\n  return [arg]\n})\n\nResponse.redirect = patchFunction(Response.redirect, (args) => {\n  args[0] = rewriteStringOrUrl(args[0])\n  return args\n})\n", "import { patchConstructor, patchFunction } from '../patch'\nimport { rewriteStringOrUrl } from '../rewrite'\nwindow.Worker = patchConstructor(Worker, (args) => [\n  rewriteStringOrUrl(args[0], self.$meteor.util.createOrigin()),\n  args[1]\n])\n\nwindow.Worklet.prototype.addModule = patchFunction(\n  Worklet.prototype.addModule,\n  (args) => [\n    rewriteStringOrUrl(args[0], self.$meteor.util.createOrigin()),\n    args[1]\n  ]\n)\n", "import { patchFunction } from '../patch'\n\nwindow.addEventListener = new Proxy(window.addEventListener, {\n  apply(target, thisArg, [type, func, ...args]) {\n    if (type === 'message' || type === 'messageerror') {\n      func = patchFunction(func, ([event]: [MessageEvent]) => {\n        Object.defineProperty(event, 'origin', {\n          value: window.$location.origin,\n          writable: false\n        })\n        return [event]\n      })\n    }\n    if (type === 'hashchange') {\n      func = patchFunction(func, ([event]: [HashChangeEvent]) => {\n        Object.defineProperty(event, 'newURL', {\n          value: self.$meteor.rewrite.url.decode(event.newURL),\n          writable: false\n        })\n        Object.defineProperty(event, 'oldURL', {\n          value: self.$meteor.rewrite.url.decode(event.oldURL),\n          writable: false\n        })\n        return [event]\n      })\n    }\n    return Reflect.apply(target, thisArg, [type, func, ...args])\n  }\n})\n", "import { patchFunction } from '../patch'\nimport { rewriteStringOrUrl } from '../rewrite'\n// biome-ignore lint:\nconst rwFun: any = ([state, , url]) => {\n  if (url) {\n    url = rewriteStringOrUrl(url)\n  }\n  return [state, '', url]\n}\nwindow.history.replaceState = patchFunction(window.history.replaceState, rwFun)\nwindow.history.pushState = patchFunction(window.history.pushState, rwFun)\n\nwindow.History.prototype.replaceState = patchFunction(\n  window.History.prototype.replaceState,\n  rwFun\n)\nwindow.History.prototype.pushState = patchFunction(\n  window.History.prototype.pushState,\n  rwFun\n)\n", "const maxRedirects = 20;\n\n// The user likely has overwritten all networking functions after importing bare-client\n// It is our responsibility to make sure components of Bare-Client are using native networking functions\nconst fetch = globalThis.fetch;\nconst WebSocket = globalThis.WebSocket;\nconst Request = globalThis.Request;\nconst Response = globalThis.Response;\nconst SharedWorker = globalThis.SharedWorker;\nconst localStorage = globalThis.localStorage;\nconst serviceWorker = globalThis.navigator.serviceWorker;\nconst WebSocketFields = {\n    prototype: {\n        send: WebSocket.prototype.send,\n    },\n    CLOSED: WebSocket.CLOSED,\n    CLOSING: WebSocket.CLOSING,\n    CONNECTING: WebSocket.CONNECTING,\n    OPEN: WebSocket.OPEN,\n};\n\nasync function searchForPort() {\n    // @ts-expect-error\n    const clients = await self.clients.matchAll({ type: \"window\", includeUncontrolled: true });\n    const promises = clients.map(async (x) => {\n        const port = await tryGetPort(x);\n        await testPort(port);\n        return port;\n    });\n    const promise = Promise.race([Promise.any(promises), new Promise((_, reject) => setTimeout(reject, 1000, new TypeError(\"timeout\")))]);\n    try {\n        return await promise;\n    }\n    catch (err) {\n        if (err instanceof AggregateError) {\n            console.error(\"bare-mux: failed to get a bare-mux SharedWorker MessagePort as all clients returned an invalid MessagePort.\");\n            throw new Error(\"All clients returned an invalid MessagePort.\");\n        }\n        console.warn(\"bare-mux: failed to get a bare-mux SharedWorker MessagePort within 1s, retrying\");\n        return await searchForPort();\n    }\n}\nfunction tryGetPort(client) {\n    let channel = new MessageChannel();\n    return new Promise(resolve => {\n        client.postMessage({ type: \"getPort\", port: channel.port2 }, [channel.port2]);\n        channel.port1.onmessage = event => {\n            resolve(event.data);\n        };\n    });\n}\nfunction testPort(port) {\n    const pingChannel = new MessageChannel();\n    const pingPromise = new Promise((resolve, reject) => {\n        pingChannel.port1.onmessage = event => {\n            if (event.data.type === \"pong\") {\n                resolve();\n            }\n        };\n        setTimeout(reject, 1500);\n    });\n    port.postMessage({ message: { type: \"ping\" }, port: pingChannel.port2 }, [pingChannel.port2]);\n    return pingPromise;\n}\nfunction createPort(path, registerHandlers) {\n    const worker = new SharedWorker(path, \"bare-mux-worker\");\n    if (registerHandlers) {\n        // @ts-expect-error we are using snapshot.ts\n        serviceWorker.addEventListener(\"message\", (event) => {\n            if (event.data.type === \"getPort\" && event.data.port) {\n                console.debug(\"bare-mux: recieved request for port from sw\");\n                const newWorker = new SharedWorker(path, \"bare-mux-worker\");\n                event.data.port.postMessage(newWorker.port, [newWorker.port]);\n            }\n        });\n    }\n    return worker.port;\n}\nlet browserSupportsTransferringStreamsCache = null;\nfunction browserSupportsTransferringStreams() {\n    if (browserSupportsTransferringStreamsCache === null) {\n        const chan = new MessageChannel();\n        const stream = new ReadableStream();\n        let res;\n        try {\n            chan.port1.postMessage(stream, [stream]);\n            res = true;\n        }\n        catch (err) {\n            res = false;\n        }\n        browserSupportsTransferringStreamsCache = res;\n        return res;\n    }\n    else {\n        return browserSupportsTransferringStreamsCache;\n    }\n}\nclass WorkerConnection {\n    constructor(worker) {\n        this.channel = new BroadcastChannel(\"bare-mux\");\n        if (worker instanceof MessagePort) {\n            this.port = worker;\n        }\n        else {\n            this.createChannel(worker, true);\n        }\n    }\n    createChannel(workerPath, inInit) {\n        // @ts-expect-error\n        if (self.clients) {\n            // running in a ServiceWorker\n            // ask a window for the worker port, register for refreshPort\n            this.port = searchForPort();\n            this.channel.onmessage = (event) => {\n                if (event.data.type === \"refreshPort\") {\n                    this.port = searchForPort();\n                }\n            };\n        }\n        else if (workerPath && SharedWorker) {\n            // running in a window, was passed a workerPath\n            // create the SharedWorker and help other bare-mux clients get the workerPath\n            if (!workerPath.startsWith(\"/\") && !workerPath.includes(\"://\"))\n                throw new Error(\"Invalid URL. Must be absolute or start at the root.\");\n            this.port = createPort(workerPath, inInit);\n            console.debug(\"bare-mux: setting localStorage bare-mux-path to\", workerPath);\n            localStorage[\"bare-mux-path\"] = workerPath;\n        }\n        else if (SharedWorker) {\n            // running in a window, was not passed a workerPath\n            // use sessionStorage for the workerPath\n            const path = localStorage[\"bare-mux-path\"];\n            console.debug(\"bare-mux: got localStorage bare-mux-path:\", path);\n            if (!path)\n                throw new Error(\"Unable to get bare-mux workerPath from localStorage.\");\n            this.port = createPort(path, inInit);\n        }\n        else {\n            // SharedWorker does not exist\n            throw new Error(\"Unable to get a channel to the SharedWorker.\");\n        }\n    }\n    async sendMessage(message, transferable) {\n        if (this.port instanceof Promise)\n            this.port = await this.port;\n        try {\n            await testPort(this.port);\n        }\n        catch {\n            console.warn(\"bare-mux: Failed to get a ping response from the worker within 1.5s. Assuming port is dead.\");\n            this.createChannel();\n            return await this.sendMessage(message, transferable);\n        }\n        const channel = new MessageChannel();\n        const toTransfer = [channel.port2, ...(transferable || [])];\n        const promise = new Promise((resolve, reject) => {\n            channel.port1.onmessage = event => {\n                const message = event.data;\n                if (message.type === \"error\") {\n                    reject(message.error);\n                }\n                else {\n                    resolve(message);\n                }\n            };\n        });\n        this.port.postMessage({ message: message, port: channel.port2 }, toTransfer);\n        return await promise;\n    }\n}\n\nconst validChars = \"!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~\";\nfunction validProtocol(protocol) {\n    for (let i = 0; i < protocol.length; i++) {\n        const char = protocol[i];\n        if (!validChars.includes(char)) {\n            return false;\n        }\n    }\n    return true;\n}\nconst wsProtocols = ['ws:', 'wss:'];\nconst statusEmpty = [101, 204, 205, 304];\nconst statusRedirect = [301, 302, 303, 307, 308];\nclass BareMuxConnection {\n    constructor(workerPath) {\n        this.worker = new WorkerConnection(workerPath);\n    }\n    async getTransport() {\n        return (await this.worker.sendMessage({ type: \"get\" })).name;\n    }\n    async setTransport(path, options) {\n        await this.setManualTransport(`\n\t\t\tconst { default: BareTransport } = await import(\"${path}\");\n\t\t\treturn [new BareTransport(${options.map(x => JSON.stringify(x)).join(\", \")}), \"${path}\"];\n\t\t`);\n    }\n    async setManualTransport(functionBody) {\n        await this.worker.sendMessage({\n            type: \"set\",\n            client: functionBody,\n        });\n    }\n    getInnerPort() {\n        return this.worker.port;\n    }\n}\nclass BareClient {\n    /**\n     * Create a BareClient. Calls to fetch and connect will wait for an implementation to be ready.\n     */\n    constructor(worker) {\n        this.worker = new WorkerConnection(worker);\n    }\n    createWebSocket(remote, protocols = [], webSocketImpl, requestHeaders, arrayBufferImpl) {\n        try {\n            remote = new URL(remote);\n        }\n        catch (err) {\n            throw new DOMException(`Faiiled to construct 'WebSocket': The URL '${remote}' is invalid.`);\n        }\n        if (!wsProtocols.includes(remote.protocol))\n            throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${remote.protocol}' is not allowed.`);\n        if (!Array.isArray(protocols))\n            protocols = [protocols];\n        protocols = protocols.map(String);\n        for (const proto of protocols)\n            if (!validProtocol(proto))\n                throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${proto}' is invalid.`);\n        let wsImpl = (webSocketImpl || WebSocket);\n        const socket = new wsImpl(\"ws://127.0.0.1:1\", protocols);\n        let fakeProtocol = '';\n        let fakeReadyState = WebSocketFields.CONNECTING;\n        let initialErrorHappened = false;\n        socket.addEventListener(\"error\", (e) => {\n            if (!initialErrorHappened) {\n                fakeReadyState = WebSocket.CONNECTING;\n                e.stopImmediatePropagation();\n                initialErrorHappened = true;\n            }\n        });\n        let initialCloseHappened = false;\n        socket.addEventListener(\"close\", (e) => {\n            if (!initialCloseHappened) {\n                e.stopImmediatePropagation();\n                initialCloseHappened = true;\n            }\n        });\n        // TODO socket onerror will be broken\n        arrayBufferImpl = arrayBufferImpl || wsImpl.constructor.constructor(\"return ArrayBuffer\")().prototype;\n        requestHeaders = requestHeaders || {};\n        requestHeaders['Host'] = (new URL(remote)).host;\n        // requestHeaders['Origin'] = origin;\n        requestHeaders['Pragma'] = 'no-cache';\n        requestHeaders['Cache-Control'] = 'no-cache';\n        requestHeaders['Upgrade'] = 'websocket';\n        // requestHeaders['User-Agent'] = navigator.userAgent;\n        requestHeaders['Connection'] = 'Upgrade';\n        const onopen = (protocol) => {\n            fakeReadyState = WebSocketFields.OPEN;\n            fakeProtocol = protocol;\n            socket.meta = {\n                headers: {\n                    \"sec-websocket-protocol\": protocol,\n                }\n            }; // what the fuck is a meta\n            socket.dispatchEvent(new Event(\"open\"));\n        };\n        const onmessage = async (payload) => {\n            if (typeof payload === \"string\") {\n                socket.dispatchEvent(new MessageEvent(\"message\", { data: payload }));\n            }\n            else if (\"byteLength\" in payload) {\n                if (socket.binaryType === \"blob\") {\n                    payload = new Blob([payload]);\n                }\n                else {\n                    Object.setPrototypeOf(payload, arrayBufferImpl);\n                }\n                socket.dispatchEvent(new MessageEvent(\"message\", { data: payload }));\n            }\n            else if (\"arrayBuffer\" in payload) {\n                if (socket.binaryType === \"arraybuffer\") {\n                    payload = await payload.arrayBuffer();\n                    Object.setPrototypeOf(payload, arrayBufferImpl);\n                }\n                socket.dispatchEvent(new MessageEvent(\"message\", { data: payload }));\n            }\n        };\n        const onclose = (code, reason) => {\n            fakeReadyState = WebSocketFields.CLOSED;\n            socket.dispatchEvent(new CloseEvent(\"close\", { code, reason }));\n        };\n        const onerror = () => {\n            fakeReadyState = WebSocketFields.CLOSED;\n            socket.dispatchEvent(new Event(\"error\"));\n        };\n        const channel = new MessageChannel();\n        channel.port1.onmessage = event => {\n            if (event.data.type === \"open\") {\n                onopen(event.data.args[0]);\n            }\n            else if (event.data.type === \"message\") {\n                onmessage(event.data.args[0]);\n            }\n            else if (event.data.type === \"close\") {\n                onclose(event.data.args[0], event.data.args[1]);\n            }\n            else if (event.data.type === \"error\") {\n                onerror( /* event.data.args[0] */);\n            }\n        };\n        this.worker.sendMessage({\n            type: \"websocket\",\n            websocket: {\n                url: remote.toString(),\n                origin: origin,\n                protocols: protocols,\n                requestHeaders: requestHeaders,\n                channel: channel.port2,\n            },\n        }, [channel.port2]);\n        // protocol is always an empty before connecting\n        // updated when we receive the metadata\n        // this value doesn't change when it's CLOSING or CLOSED etc\n        const getReadyState = () => fakeReadyState;\n        // we have to hook .readyState ourselves\n        Object.defineProperty(socket, 'readyState', {\n            get: getReadyState,\n            configurable: true,\n            enumerable: true,\n        });\n        /**\n         * @returns The error that should be thrown if send() were to be called on this socket according to the fake readyState value\n         */\n        const getSendError = () => {\n            const readyState = getReadyState();\n            if (readyState === WebSocketFields.CONNECTING)\n                return new DOMException(\"Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.\");\n        };\n        // we have to hook .send ourselves\n        // use ...args to avoid giving the number of args a quantity\n        // no arguments will trip the following error: TypeError: Failed to execute 'send' on 'WebSocket': 1 argument required, but only 0 present.\n        socket.send = function (...args) {\n            const error = getSendError();\n            if (error)\n                throw error;\n            let data = args[0];\n            // @ts-expect-error idk why it errors?\n            if (data.buffer)\n                data = data.buffer;\n            channel.port1.postMessage({ type: \"data\", data: data }, data instanceof ArrayBuffer ? [data] : []);\n        };\n        socket.close = function (code, reason) {\n            channel.port1.postMessage({ type: \"close\", closeCode: code, closeReason: reason });\n        };\n        Object.defineProperty(socket, 'url', {\n            get: () => remote.toString(),\n            configurable: true,\n            enumerable: true,\n        });\n        const getProtocol = () => fakeProtocol;\n        Object.defineProperty(socket, 'protocol', {\n            get: getProtocol,\n            configurable: true,\n            enumerable: true,\n        });\n        return socket;\n    }\n    async fetch(url, init) {\n        // Only create an instance of Request to parse certain parameters of init such as method, headers, redirect\n        // But use init values whenever possible\n        const req = new Request(url, init);\n        // try to use init.headers because it may contain capitalized headers\n        // furthermore, important headers on the Request class are blocked...\n        // we should try to preserve the capitalization due to quirks with earlier servers\n        const inputHeaders = init?.headers || req.headers;\n        const headers = inputHeaders instanceof Headers\n            ? Object.fromEntries(inputHeaders)\n            : inputHeaders;\n        const body = req.body;\n        let urlO = new URL(req.url);\n        if (urlO.protocol.startsWith('blob:')) {\n            const response = await fetch(urlO);\n            const result = new Response(response.body, response);\n            result.rawHeaders = Object.fromEntries(response.headers);\n            result.rawResponse = response;\n            return result;\n        }\n        for (let i = 0;; i++) {\n            if ('host' in headers)\n                headers.host = urlO.host;\n            else\n                headers.Host = urlO.host;\n            let resp = (await this.worker.sendMessage({\n                type: \"fetch\",\n                fetch: {\n                    remote: urlO.toString(),\n                    method: req.method,\n                    headers: headers,\n                    body: body || undefined,\n                },\n            }, body ? [body] : [])).fetch;\n            let responseobj = new Response(statusEmpty.includes(resp.status) ? undefined : resp.body, {\n                headers: new Headers(resp.headers),\n                status: resp.status,\n                statusText: resp.statusText,\n            });\n            responseobj.rawHeaders = resp.headers;\n            responseobj.rawResponse = new Response(resp.body);\n            responseobj.finalURL = urlO.toString();\n            const redirect = init?.redirect || req.redirect;\n            if (statusRedirect.includes(responseobj.status)) {\n                switch (redirect) {\n                    case 'follow': {\n                        const location = responseobj.headers.get('location');\n                        if (maxRedirects > i && location !== null) {\n                            urlO = new URL(location, urlO);\n                            continue;\n                        }\n                        else\n                            throw new TypeError('Failed to fetch');\n                    }\n                    case 'error':\n                        throw new TypeError('Failed to fetch');\n                    case 'manual':\n                        return responseobj;\n                }\n            }\n            else {\n                return responseobj;\n            }\n        }\n    }\n}\n\nexport { BareClient, BareMuxConnection, WebSocketFields, WorkerConnection, browserSupportsTransferringStreams, BareClient as default, maxRedirects, validProtocol };\n//# sourceMappingURL=index.mjs.map\n", "import BareClient from '@mercuryworkshop/bare-mux'\nconst client = new BareClient()\nconst RealWebSocket = globalThis.WebSocket\n\nglobalThis.WebSocket = new Proxy(globalThis.WebSocket, {\n  construct(_target, args) {\n    if (self.$meteor_config.debug === true) {\n      self.$meteor.util.log(\n        `Creating websocket to ${args[0]} on origin ${self.$meteor.util.createOrigin().origin}`,\n        'teal'\n      )\n    }\n    return client.createWebSocket(\n      args[0],\n      args[1],\n      RealWebSocket,\n      {\n        'User-Agent': navigator.userAgent,\n        origin: self.$location.origin\n      },\n      ArrayBuffer.prototype\n    )\n  }\n})\n", "import { patchFunction } from '../patch'\nimport { rewriteStringOrUrl } from '../rewrite'\n\nObject.defineProperties(window.navigator, {})\n\nif ('sendBeacon' in globalThis.navigator) {\n  globalThis.navigator.sendBeacon = patchFunction(\n    globalThis.navigator.sendBeacon,\n    (args) => {\n      args[0] = rewriteStringOrUrl(args[0])\n      return args\n    }\n  )\n}\n\nif ('clipboard' in globalThis.navigator) {\n  // @ts-expect-error this can be ignored\n  globalThis.navigator.clipboard = patchFunction(\n    // @ts-expect-error this can also be ignored\n    globalThis.navigator.clipboard,\n    (args) => {\n      args[0]\n      return args\n    }\n  )\n}\n\nif ('credentials' in globalThis.navigator) {\n  // @ts-expect-error this can be ignored\n  globalThis.navigator.credentials = patchFunction(\n    // @ts-expect-error this can also be ignored\n    globalThis.navigator.credentials,\n    (args) => {\n      self.$meteor.util.log(`Attempting to patch: ${args}`, 'teal')\n      return args\n    }\n  )\n}\n", "const STORAGE_PREFIX = 'meteor$'\n\nfunction createStorageProxy(storage: Storage) {\n  const filterBySite = () =>\n    Object.keys(storage).filter((key) =>\n      key.startsWith(STORAGE_PREFIX + window.$location.host)\n    )\n\n  return new Proxy(storage, {\n    get(target, key) {\n      switch (key) {\n        case 'setItem':\n          return (key: string, value: string) =>\n            target.setItem(\n              `${STORAGE_PREFIX}${window.$location.host}@${key}`,\n              value\n            )\n\n        case 'getItem':\n          return (key: string) =>\n            target.getItem(`${STORAGE_PREFIX}${window.$location.host}@${key}`)\n\n        case 'removeItem':\n          return (key: string) =>\n            target.removeItem(\n              `${STORAGE_PREFIX}${window.$location.host}@${key}`\n            )\n\n        case 'clear':\n          return () => {\n            for (const key of filterBySite()) {\n              target.removeItem(key)\n            }\n          }\n\n        case 'length':\n          return filterBySite().length\n\n        case 'key':\n          return (index: number) => target[filterBySite()[index]]\n      }\n    }\n  })\n}\n\nconst ls = createStorageProxy(window.localStorage)\nconst ss = createStorageProxy(window.sessionStorage)\n// biome-ignore lint: you need to delete it like this, setting as undefined does NOT work\ndelete window.localStorage\n// biome-ignore lint: ^\ndelete window.sessionStorage\n\nwindow.localStorage = ls\nwindow.sessionStorage = ss\n", "// !! Warning !!\n// Leave `dom` as the first import\n// Things might break intentionally\n\nimport './dom'\nimport './apis/css'\nimport './apis/location'\nimport './apis/requests'\nimport './apis/workers'\nimport './apis/eventlistener'\nimport './apis/history'\nimport './apis/ws'\nimport './apis/navigator'\nimport './apis/storage'\n\ndeclare global {\n  interface Window {\n    $location: Location\n  }\n  interface globalThis {\n    $location: Location\n  }\n  interface Document {\n    $location: Location\n  }\n}\n\nfor (const plugin of self.$meteor.config.plugins) {\n  if (plugin.filter.test(window.$location.href)) {\n    if ('handleClient' in plugin) {\n      self.$meteor.util.log(`Running handleClient for ${plugin.name}`, 'teal')\n      plugin.handleClient(window)\n    }\n  }\n}\n"],
  "mappings": "MAAO,SAASA,EAAcC,EAAgBC,EAAa,CACzD,OAAOD,EACJ,MAAM,IAAI,EACV,IAAKE,GACGA,EACJ,MAAM,GAAG,EACT,IAAI,CAACC,EAAKC,IACFA,IAAU,EACb,KAAK,QAAQ,QAAQ,IAAI,OAAOD,EAAKF,CAAM,EAC3CE,CACL,EACA,KAAK,GAAG,CACZ,EACA,KAAK,IAAI,CACd,CCPO,SAASE,EACdC,EACAC,EACG,CACH,OAAO,IAAI,MAAMD,EAAQ,CACvB,MAAMA,EAAWE,EAAkBC,EAAwC,CACzE,IAAMC,EAAcH,EAAME,CAAQ,EAClC,OAAO,QAAQ,MAAMH,EAAQE,EAASE,CAAW,CACnD,CACF,CAAC,CACH,CAEO,SAASC,EACdL,EACAC,EACG,CACH,OAAO,IAAI,MAAMD,EAAQ,CACvB,UACEA,EACAG,EACAG,EACiB,CACjB,IAAMF,EAAcH,EAAME,CAAQ,EAClC,OAAO,QAAQ,UAAUH,EAAQI,EAAaE,CAAS,CACzD,CACF,CAAC,CACH,CC7BA,IAAMC,EAKF,CACF,IAAK,CACH,kBACA,iBACA,iBACA,kBACA,iBACF,EACA,KAAM,CAAC,kBAAmB,eAAe,EACzC,OAAQ,CAAC,eAAe,EACxB,WAAY,CAAC,gBAAgB,EAC7B,KAAM,CAAC,iBAAiB,CAC1B,EAEMC,EAAW,CAAC,QAAS,YAAa,KAAK,EAE7C,OAAW,CAACC,EAAMC,CAAI,IAAK,OAAO,QAAQH,CAAa,EACrD,QAAWI,KAAOD,EAAM,CACtB,IAAME,EAAc,OAAO,yBAAyBD,EAAI,UAAWF,CAAI,EACvE,OAAO,eAAeE,EAAI,UAAWF,EAAM,CACzC,KAAM,CACJ,OAAO,KAAK,QAAQ,QAAQ,IAAI,OAAOG,EAAY,IAAI,KAAK,IAAI,CAAC,CACnE,EACA,IAAIC,EAAO,CACTA,EAAQ,KAAK,QAAQ,QAAQ,IAAI,OAC/BA,EACA,IAAI,IAAI,KAAK,UAAU,MAAM,CAC/B,EACAD,EAAY,IAAI,KAAK,KAAMC,CAAK,CAClC,CACF,CAAC,CACH,CAGF,IAAMC,EAAsB,OAAO,yBACjC,QAAQ,UACR,WACF,EAEA,OAAO,eAAe,QAAQ,UAAW,YAAa,CACpD,IAAID,EAAO,CACT,OAAI,gBAAgB,kBAClBA,EAAQ,KAAK,QAAQ,QAAQ,GAAGA,EAAO,IAAI,IAAI,KAAK,UAAU,MAAM,CAAC,EAC5D,gBAAgB,mBACzBA,EAAQ,KAAK,QAAQ,QAAQ,IAAIA,EAAO,IAAI,IAAI,KAAK,UAAU,MAAM,CAAC,GAGjEC,EAAoB,IAAI,KAAK,KAAMD,CAAK,CACjD,CACF,CAAC,EAED,IAAME,EAAmB,OAAO,yBAC9B,iBAAiB,UACjB,QACF,EAEA,OAAO,eAAe,iBAAiB,UAAW,SAAU,CAC1D,KAAM,CACJ,OAAOA,EAAiB,IAAI,KAAK,IAAI,CACvC,EACA,IAAIF,EAAO,CACTA,EAAQG,EAAcH,EAAO,IAAI,IAAI,KAAK,UAAU,MAAM,CAAC,EAC3DE,EAAiB,IAAI,KAAK,KAAMF,CAAK,CACvC,CACF,CAAC,EAED,QAAQ,UAAU,aAAeI,EAC/B,QAAQ,UAAU,aAClB,CAAC,CAACR,CAAI,IACAD,EAAS,SAASC,CAAI,EACjB,KAEF,CAACA,CAAI,CAEhB,EAEA,QAAQ,UAAU,aAAeQ,EAC/B,QAAQ,UAAU,aAClB,CAAC,CAACR,EAAMI,CAAK,IACPL,EAAS,SAASC,CAAI,EACjB,CAACA,EAAM,EAAE,GAEdF,EAAcE,CAAI,IACpBI,EAAQ,KAAK,QAAQ,QAAQ,IAAI,OAC/BA,EACA,IAAI,IAAI,KAAK,UAAU,MAAM,CAC/B,GAEEJ,IAAS,UACXI,EAAQ,KAAK,QAAQ,QAAQ,IAAIA,EAAO,IAAI,IAAI,KAAK,UAAU,MAAM,CAAC,GAEpEJ,EAAK,SAAS,QAAQ,IACxBI,EAAQG,EAAcH,EAAO,IAAI,IAAI,KAAK,UAAU,MAAM,CAAC,GAEtD,CAACJ,EAAMI,CAAK,EAEvB,ECxGA,IAAMK,EAAW,CACf,aACA,mBACA,OACA,aACA,aACA,mBACA,eACA,sBACA,QACF,EACA,oBAAoB,UAAU,YAAcC,EAC1C,oBAAoB,UAAU,YAC9B,CAAC,CAACC,EAAMC,EAAU,GAAAC,CAAI,KAChBJ,EAAS,SAASE,CAAI,IACxBC,EAAQ,KAAK,QAAQ,QAAQ,IAAIA,EAAO,IAAI,IAAI,KAAK,UAAU,MAAM,CAAC,GAEjE,CAACD,EAAMC,EAAO,GAAGC,CAAI,EAEhC,ECpBA,OAAO,UAAY,OAAO,OAAO,OAAO,QAAQ,EAChD,OAAO,iBAAiB,OAAO,UAAW,CACxC,SAAU,CACR,OAAQ,CACN,OAAO,KAAK,QAAQ,KAAK,aAAa,EAAE,SAAS,CACnD,CACF,EACA,KAAM,CACJ,KAAM,CAMJ,OAAO,KAAK,QAAQ,KAAK,aAAa,EAAE,IAC1C,EACA,IAAIC,EAAO,CACT,KAAK,QAAQ,QAAQ,IAAI,OAAOA,EAAO,KAAK,QAAQ,KAAK,aAAa,CAAC,CACzE,CACF,EACA,OAAQ,CACN,KAAM,CACJ,OAAO,KAAK,QAAQ,KAAK,aAAa,EAAE,MAC1C,CACF,EACA,OAAQ,CACN,KAAM,CACJ,OAAO,KAAK,QAAQ,KAAK,aAAa,EAAE,MAC1C,EACA,IAAIA,EAAO,CACT,OAAO,SAAS,OAAS,KAAK,QAAQ,OAAO,MAAM,OAAOA,CAAK,CACjE,CACF,EACA,KAAM,CACJ,KAAM,CACJ,OAAO,KAAK,QAAQ,KAAK,aAAa,EAAE,IAC1C,CACF,EACA,SAAU,CACR,KAAM,CACJ,OAAO,KAAK,QAAQ,KAAK,aAAa,EAAE,QAC1C,EACA,IAAIA,EAAO,CACT,IAAMC,EAAM,KAAK,QAAQ,KAAK,aAAa,EAC3CA,EAAI,SAAWD,EACf,OAAO,SAAS,SAAW,KAAK,QAAQ,QAAQ,IAAI,OAClDC,EAAI,SAAS,EACbA,CACF,CACF,CACF,EACA,SAAU,CACR,KAAM,CACJ,OAAO,KAAK,QAAQ,KAAK,aAAa,EAAE,QAC1C,EACA,KAAM,CAAC,CACT,EACA,KAAM,CACJ,KAAM,CACJ,OAAO,KAAK,QAAQ,KAAK,aAAa,EAAE,IAC1C,EACA,IAAID,EAAO,CACT,IAAMC,EAAM,KAAK,QAAQ,KAAK,aAAa,EAC3CA,EAAI,KAAOD,EACX,OAAO,SAAS,KAAO,KAAK,QAAQ,QAAQ,IAAI,OAC9CC,EAAI,SAAS,EACbA,CACF,CACF,CACF,EACA,SAAU,CACR,KAAM,CACJ,OAAO,KAAK,QAAQ,KAAK,aAAa,EAAE,QAC1C,EACA,IAAID,EAAO,CACT,IAAMC,EAAM,KAAK,QAAQ,KAAK,aAAa,EAC3CA,EAAI,SAAWD,EACf,OAAO,SAAS,SAAW,KAAK,QAAQ,QAAQ,IAAI,OAClDC,EAAI,SAAS,EACbA,CACF,CACF,CACF,EACA,KAAM,CACJ,KAAM,CACJ,OAAO,KAAK,QAAQ,KAAK,aAAa,EAAE,IAC1C,EACA,KAAM,CAAC,CACT,EACA,QAAS,CACP,MAAMA,EAAa,CACjB,SAAS,QACP,KAAK,QAAQ,QAAQ,IAAI,OAAOA,EAAK,KAAK,QAAQ,KAAK,aAAa,CAAC,CACvE,CACF,CACF,CACF,CAAC,EACD,WAAW,UAAY,OAAO,UAC9B,SAAS,UAAY,OAAO,UClG5B,IAAMC,EAAc,CAClB,+BACA,6BACA,+BACA,0BACA,sCACA,YACA,iBACA,mBACA,4BACA,4BACA,yBACA,qBACA,kBACA,oCACA,eACA,mBACA,iBACF,EAEMC,EAAiB,CAAC,OAAQ,QAAQ,EAEjC,SAASC,EACdC,EACAC,EACAC,EAAkB,QAClB,CACA,IAAMC,EAAa,IAAID,EAEvB,OAAW,CAACE,EAAKC,CAAK,IAAKL,EAAQ,QAAQ,EACzCG,EAAW,IAAIC,EAAI,YAAY,EAAGC,CAAK,EAEzC,QAAWC,KAAUT,EAAaM,EAAW,OAAOG,CAAM,EAE1D,QAAWA,IAAU,CAAC,UAAW,WAAY,kBAAkB,EAC7DH,EAAW,IACTG,EACA,KAAK,QAAQ,QAAQ,IAAI,OAAOH,EAAW,IAAIG,CAAM,EAAGL,CAAM,CAChE,EAEF,QAAWK,KAAUR,EACfK,EAAW,IAAIG,CAAM,GACvBH,EAAW,IACTG,EACA,IAAI,IACF,KAAK,QAAQ,QAAQ,IAAI,OAAOH,EAAW,IAAIG,CAAM,EAAGL,CAAM,CAChE,EAAEK,CAAM,CACV,EAGJ,OAAIH,EAAW,IAAI,MAAM,GACvBA,EAAW,IACT,OACAA,EACG,IAAI,MAAM,EACV,QAAQ,YAAcI,GACrB,KAAK,QAAQ,QAAQ,IAAI,OAAOA,EAAON,CAAM,CAC/C,CACJ,EAGKE,CACT,CC9DO,SAASK,EAAmBC,EAAqBC,EAAc,CAKpE,OAJKA,IACHA,EAAS,KAAK,QAAQ,KAAK,aAAa,GAGtCD,aAAiB,IACZ,IAAI,IACT,KAAK,QAAQ,QAAQ,IAAI,OACvBA,EAAM,SAAS,EACf,KAAK,QAAQ,KAAK,aAAa,CACjC,CACF,EAGK,KAAK,QAAQ,QAAQ,IAAI,OAC9BA,EACA,KAAK,QAAQ,KAAK,aAAa,CACjC,CACF,CCfA,IAAME,EAAa,WAAW,QAC9B,OAAO,MAAQC,EAAc,OAAO,MAAQC,GAAS,CACnD,GAAIA,EAAK,CAAC,YAAa,QAAS,CAC9B,IAAMC,EAAUD,EAAK,CAAC,EACtBA,EAAK,CAAC,EAAI,IAAI,QACZ,KAAK,QAAQ,QAAQ,IAAI,OACvBC,EAAQ,IACR,KAAK,QAAQ,KAAK,aAAa,CACjC,EACA,OAAO,eAAeA,EAAS,MAAO,CAAE,MAAO,MAAU,CAAC,CAC5D,CACF,MACED,EAAK,CAAC,EAAIE,EAAmBF,EAAK,CAAC,CAAC,EAGtC,OAAOA,CACT,CAAC,EAED,OAAO,eAAe,UAAU,KAAOD,EACrC,eAAe,UAAU,KACxBC,IACKA,EAAK,CAAC,YAAa,IACrBA,EAAK,CAAC,EAAI,IAAI,IACZ,KAAK,QAAQ,QAAQ,IAAI,OACvBA,EAAK,CAAC,EAAE,KACR,KAAK,QAAQ,KAAK,aAAa,CACjC,CACF,EAEAA,EAAK,CAAC,EAAI,KAAK,QAAQ,QAAQ,IAAI,OACjCA,EAAK,CAAC,EACN,KAAK,QAAQ,KAAK,aAAa,CACjC,EAGKA,EAEX,EAEA,OAAO,QAAUG,EAAiB,QAAUH,GAAS,CACnD,GAAIA,EAAK,CAAC,YAAa,QAAS,CAC9B,IAAMC,EAAUD,EAAK,CAAC,EACtBA,EAAK,CAAC,EAAI,IAAI,QACZ,KAAK,QAAQ,QAAQ,IAAI,OACvBC,EAAQ,IACR,KAAK,QAAQ,KAAK,aAAa,CACjC,EACA,OAAO,eAAeA,EAAS,MAAO,CAAE,MAAO,MAAU,CAAC,CAC5D,CACF,MACED,EAAK,CAAC,EAAIE,EAAmBF,EAAK,CAAC,CAAC,EAEtC,OAAOA,CACT,CAAC,EACD,OAAO,QAAUG,EAAiB,QAAS,CAAC,CAACC,CAAG,KAC9CA,EAAMC,EACJ,IAAIP,EAAWM,CAAG,EAClB,KAAK,QAAQ,KAAK,aAAa,EAC/BN,CACF,EACO,CAACM,CAAG,EACZ,EAED,SAAS,SAAWL,EAAc,SAAS,SAAWC,IACpDA,EAAK,CAAC,EAAIE,EAAmBF,EAAK,CAAC,CAAC,EAC7BA,EACR,ECnED,OAAO,OAASM,EAAiB,OAASC,GAAS,CACjDC,EAAmBD,EAAK,CAAC,EAAG,KAAK,QAAQ,KAAK,aAAa,CAAC,EAC5DA,EAAK,CAAC,CACR,CAAC,EAED,OAAO,QAAQ,UAAU,UAAYE,EACnC,QAAQ,UAAU,UACjBF,GAAS,CACRC,EAAmBD,EAAK,CAAC,EAAG,KAAK,QAAQ,KAAK,aAAa,CAAC,EAC5DA,EAAK,CAAC,CACR,CACF,ECXA,OAAO,iBAAmB,IAAI,MAAM,OAAO,iBAAkB,CAC3D,MAAMG,EAAQC,EAAS,CAACC,EAAMC,EAAM,GAAGC,CAAI,EAAG,CAC5C,OAAIF,IAAS,WAAaA,IAAS,kBACjCC,EAAOE,EAAcF,EAAM,CAAC,CAACG,CAAK,KAChC,OAAO,eAAeA,EAAO,SAAU,CACrC,MAAO,OAAO,UAAU,OACxB,SAAU,EACZ,CAAC,EACM,CAACA,CAAK,EACd,GAECJ,IAAS,eACXC,EAAOE,EAAcF,EAAM,CAAC,CAACG,CAAK,KAChC,OAAO,eAAeA,EAAO,SAAU,CACrC,MAAO,KAAK,QAAQ,QAAQ,IAAI,OAAOA,EAAM,MAAM,EACnD,SAAU,EACZ,CAAC,EACD,OAAO,eAAeA,EAAO,SAAU,CACrC,MAAO,KAAK,QAAQ,QAAQ,IAAI,OAAOA,EAAM,MAAM,EACnD,SAAU,EACZ,CAAC,EACM,CAACA,CAAK,EACd,GAEI,QAAQ,MAAMN,EAAQC,EAAS,CAACC,EAAMC,EAAM,GAAGC,CAAI,CAAC,CAC7D,CACF,CAAC,ECzBD,IAAMG,EAAa,CAAC,CAACC,EAAO,CAAEC,CAAG,KAC3BA,IACFA,EAAMC,EAAmBD,CAAG,GAEvB,CAACD,EAAO,GAAIC,CAAG,GAExB,OAAO,QAAQ,aAAeE,EAAc,OAAO,QAAQ,aAAcJ,CAAK,EAC9E,OAAO,QAAQ,UAAYI,EAAc,OAAO,QAAQ,UAAWJ,CAAK,EAExE,OAAO,QAAQ,UAAU,aAAeI,EACtC,OAAO,QAAQ,UAAU,aACzBJ,CACF,EACA,OAAO,QAAQ,UAAU,UAAYI,EACnC,OAAO,QAAQ,UAAU,UACzBJ,CACF,ECfA,IAAMK,EAAQ,WAAW,MACnBC,EAAY,WAAW,UACvBC,EAAU,WAAW,QACrBC,EAAW,WAAW,SACtBC,EAAe,WAAW,aAC1BC,EAAe,WAAW,aAC1BC,EAAgB,WAAW,UAAU,cACrCC,EAAkB,CACpB,UAAW,CACP,KAAMN,EAAU,UAAU,IAC9B,EACA,OAAQA,EAAU,OAClB,QAASA,EAAU,QACnB,WAAYA,EAAU,WACtB,KAAMA,EAAU,IACpB,EAEA,eAAeO,GAAgB,CAG3B,IAAMC,GADU,MAAM,KAAK,QAAQ,SAAS,CAAE,KAAM,SAAU,oBAAqB,EAAK,CAAC,GAChE,IAAI,MAAOC,GAAM,CACtC,IAAMC,EAAO,MAAMC,EAAWF,CAAC,EAC/B,aAAMG,EAASF,CAAI,EACZA,CACX,CAAC,EACKG,EAAU,QAAQ,KAAK,CAAC,QAAQ,IAAIL,CAAQ,EAAG,IAAI,QAAQ,CAACM,EAAGC,IAAW,WAAWA,EAAQ,IAAM,IAAI,UAAU,SAAS,CAAC,CAAC,CAAC,CAAC,EACpI,GAAI,CACA,OAAO,MAAMF,CACjB,OACOG,EAAK,CACR,GAAIA,aAAe,eACf,cAAQ,MAAM,6GAA6G,EACrH,IAAI,MAAM,8CAA8C,EAElE,eAAQ,KAAK,iFAAiF,EACvF,MAAMT,EAAc,CAC/B,CACJ,CACA,SAASI,EAAWM,EAAQ,CACxB,IAAIC,EAAU,IAAI,eAClB,OAAO,IAAI,QAAQC,GAAW,CAC1BF,EAAO,YAAY,CAAE,KAAM,UAAW,KAAMC,EAAQ,KAAM,EAAG,CAACA,EAAQ,KAAK,CAAC,EAC5EA,EAAQ,MAAM,UAAYE,GAAS,CAC/BD,EAAQC,EAAM,IAAI,CACtB,CACJ,CAAC,CACL,CACA,SAASR,EAASF,EAAM,CACpB,IAAMW,EAAc,IAAI,eAClBC,EAAc,IAAI,QAAQ,CAACH,EAASJ,IAAW,CACjDM,EAAY,MAAM,UAAYD,GAAS,CAC/BA,EAAM,KAAK,OAAS,QACpBD,EAAQ,CAEhB,EACA,WAAWJ,EAAQ,IAAI,CAC3B,CAAC,EACD,OAAAL,EAAK,YAAY,CAAE,QAAS,CAAE,KAAM,MAAO,EAAG,KAAMW,EAAY,KAAM,EAAG,CAACA,EAAY,KAAK,CAAC,EACrFC,CACX,CACA,SAASC,EAAWC,EAAMC,EAAkB,CACxC,IAAMC,EAAS,IAAIvB,EAAaqB,EAAM,iBAAiB,EACvD,OAAIC,GAEApB,EAAc,iBAAiB,UAAYe,GAAU,CACjD,GAAIA,EAAM,KAAK,OAAS,WAAaA,EAAM,KAAK,KAAM,CAClD,QAAQ,MAAM,6CAA6C,EAC3D,IAAMO,EAAY,IAAIxB,EAAaqB,EAAM,iBAAiB,EAC1DJ,EAAM,KAAK,KAAK,YAAYO,EAAU,KAAM,CAACA,EAAU,IAAI,CAAC,CAChE,CACJ,CAAC,EAEED,EAAO,IAClB,CAqBA,IAAME,EAAN,KAAuB,CACnB,YAAYC,EAAQ,CAChB,KAAK,QAAU,IAAI,iBAAiB,UAAU,EAC1CA,aAAkB,YAClB,KAAK,KAAOA,EAGZ,KAAK,cAAcA,EAAQ,EAAI,CAEvC,CACA,cAAcC,EAAYC,EAAQ,CAE9B,GAAI,KAAK,QAGL,KAAK,KAAOC,EAAc,EAC1B,KAAK,QAAQ,UAAaC,GAAU,CAC5BA,EAAM,KAAK,OAAS,gBACpB,KAAK,KAAOD,EAAc,EAElC,UAEKF,GAAcI,EAAc,CAGjC,GAAI,CAACJ,EAAW,WAAW,GAAG,GAAK,CAACA,EAAW,SAAS,KAAK,EACzD,MAAM,IAAI,MAAM,qDAAqD,EACzE,KAAK,KAAOK,EAAWL,EAAYC,CAAM,EACzC,QAAQ,MAAM,kDAAmDD,CAAU,EAC3EM,EAAa,eAAe,EAAIN,CACpC,SACSI,EAAc,CAGnB,IAAMG,EAAOD,EAAa,eAAe,EAEzC,GADA,QAAQ,MAAM,4CAA6CC,CAAI,EAC3D,CAACA,EACD,MAAM,IAAI,MAAM,sDAAsD,EAC1E,KAAK,KAAOF,EAAWE,EAAMN,CAAM,CACvC,KAGI,OAAM,IAAI,MAAM,8CAA8C,CAEtE,CACA,MAAM,YAAYO,EAASC,EAAc,CACjC,KAAK,gBAAgB,UACrB,KAAK,KAAO,MAAM,KAAK,MAC3B,GAAI,CACA,MAAMC,EAAS,KAAK,IAAI,CAC5B,MACM,CACF,eAAQ,KAAK,6FAA6F,EAC1G,KAAK,cAAc,EACZ,MAAM,KAAK,YAAYF,EAASC,CAAY,CACvD,CACA,IAAME,EAAU,IAAI,eACdC,EAAa,CAACD,EAAQ,MAAO,GAAIF,GAAgB,CAAC,CAAE,EACpDI,EAAU,IAAI,QAAQ,CAACC,EAASC,IAAW,CAC7CJ,EAAQ,MAAM,UAAYR,GAAS,CAC/B,IAAMK,EAAUL,EAAM,KAClBK,EAAQ,OAAS,QACjBO,EAAOP,EAAQ,KAAK,EAGpBM,EAAQN,CAAO,CAEvB,CACJ,CAAC,EACD,YAAK,KAAK,YAAY,CAAE,QAASA,EAAS,KAAMG,EAAQ,KAAM,EAAGC,CAAU,EACpE,MAAMC,CACjB,CACJ,EAEMG,EAAa,gFACnB,SAASC,EAAcC,EAAU,CAC7B,QAASC,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAAK,CACtC,IAAMC,EAAOF,EAASC,CAAC,EACvB,GAAI,CAACH,EAAW,SAASI,CAAI,EACzB,MAAO,EAEf,CACA,MAAO,EACX,CACA,IAAMC,GAAc,CAAC,MAAO,MAAM,EAC5BC,GAAc,CAAC,IAAK,IAAK,IAAK,GAAG,EACjCC,GAAiB,CAAC,IAAK,IAAK,IAAK,IAAK,GAAG,EAwB/C,IAAMC,EAAN,KAAiB,CAIb,YAAYC,EAAQ,CAChB,KAAK,OAAS,IAAIC,EAAiBD,CAAM,CAC7C,CACA,gBAAgBE,EAAQC,EAAY,CAAC,EAAGC,EAAeC,EAAgBC,EAAiB,CACpF,GAAI,CACAJ,EAAS,IAAI,IAAIA,CAAM,CAC3B,MACY,CACR,MAAM,IAAI,aAAa,8CAA8CA,CAAM,eAAe,CAC9F,CACA,GAAI,CAACK,GAAY,SAASL,EAAO,QAAQ,EACrC,MAAM,IAAI,aAAa,oFAAoFA,EAAO,QAAQ,mBAAmB,EAC5I,MAAM,QAAQC,CAAS,IACxBA,EAAY,CAACA,CAAS,GAC1BA,EAAYA,EAAU,IAAI,MAAM,EAChC,QAAWK,KAASL,EAChB,GAAI,CAACM,EAAcD,CAAK,EACpB,MAAM,IAAI,aAAa,qDAAqDA,CAAK,eAAe,EACxG,IAAIE,EAAUN,GAAiBO,EACzBC,EAAS,IAAIF,EAAO,mBAAoBP,CAAS,EACnDU,EAAe,GACfC,EAAiBC,EAAgB,WACjCC,EAAuB,GAC3BJ,EAAO,iBAAiB,QAAUK,GAAM,CAC/BD,IACDF,EAAiBH,EAAU,WAC3BM,EAAE,yBAAyB,EAC3BD,EAAuB,GAE/B,CAAC,EACD,IAAIE,EAAuB,GAC3BN,EAAO,iBAAiB,QAAUK,GAAM,CAC/BC,IACDD,EAAE,yBAAyB,EAC3BC,EAAuB,GAE/B,CAAC,EAEDZ,EAAkBA,GAAmBI,EAAO,YAAY,YAAY,oBAAoB,EAAE,EAAE,UAC5FL,EAAiBA,GAAkB,CAAC,EACpCA,EAAe,KAAW,IAAI,IAAIH,CAAM,EAAG,KAE3CG,EAAe,OAAY,WAC3BA,EAAe,eAAe,EAAI,WAClCA,EAAe,QAAa,YAE5BA,EAAe,WAAgB,UAC/B,IAAMc,EAAUC,GAAa,CACzBN,EAAiBC,EAAgB,KACjCF,EAAeO,EACfR,EAAO,KAAO,CACV,QAAS,CACL,yBAA0BQ,CAC9B,CACJ,EACAR,EAAO,cAAc,IAAI,MAAM,MAAM,CAAC,CAC1C,EACMS,EAAY,MAAOC,GAAY,CAC7B,OAAOA,GAAY,SACnBV,EAAO,cAAc,IAAI,aAAa,UAAW,CAAE,KAAMU,CAAQ,CAAC,CAAC,EAE9D,eAAgBA,GACjBV,EAAO,aAAe,OACtBU,EAAU,IAAI,KAAK,CAACA,CAAO,CAAC,EAG5B,OAAO,eAAeA,EAAShB,CAAe,EAElDM,EAAO,cAAc,IAAI,aAAa,UAAW,CAAE,KAAMU,CAAQ,CAAC,CAAC,GAE9D,gBAAiBA,IAClBV,EAAO,aAAe,gBACtBU,EAAU,MAAMA,EAAQ,YAAY,EACpC,OAAO,eAAeA,EAAShB,CAAe,GAElDM,EAAO,cAAc,IAAI,aAAa,UAAW,CAAE,KAAMU,CAAQ,CAAC,CAAC,EAE3E,EACMC,EAAU,CAACC,EAAMC,IAAW,CAC9BX,EAAiBC,EAAgB,OACjCH,EAAO,cAAc,IAAI,WAAW,QAAS,CAAE,KAAAY,EAAM,OAAAC,CAAO,CAAC,CAAC,CAClE,EACMC,EAAU,IAAM,CAClBZ,EAAiBC,EAAgB,OACjCH,EAAO,cAAc,IAAI,MAAM,OAAO,CAAC,CAC3C,EACMe,EAAU,IAAI,eACpBA,EAAQ,MAAM,UAAYC,GAAS,CAC3BA,EAAM,KAAK,OAAS,OACpBT,EAAOS,EAAM,KAAK,KAAK,CAAC,CAAC,EAEpBA,EAAM,KAAK,OAAS,UACzBP,EAAUO,EAAM,KAAK,KAAK,CAAC,CAAC,EAEvBA,EAAM,KAAK,OAAS,QACzBL,EAAQK,EAAM,KAAK,KAAK,CAAC,EAAGA,EAAM,KAAK,KAAK,CAAC,CAAC,EAEzCA,EAAM,KAAK,OAAS,SACzBF,EAAiC,CAEzC,EACA,KAAK,OAAO,YAAY,CACpB,KAAM,YACN,UAAW,CACP,IAAKxB,EAAO,SAAS,EACrB,OACA,UAAWC,EACX,eAAgBE,EAChB,QAASsB,EAAQ,KACrB,CACJ,EAAG,CAACA,EAAQ,KAAK,CAAC,EAIlB,IAAME,EAAgB,IAAMf,EAE5B,OAAO,eAAeF,EAAQ,aAAc,CACxC,IAAKiB,EACL,aAAc,GACd,WAAY,EAChB,CAAC,EAID,IAAMC,EAAe,IAAM,CAEvB,GADmBD,EAAc,IACdd,EAAgB,WAC/B,OAAO,IAAI,aAAa,qEAAqE,CACrG,EAIA,OAAAH,EAAO,KAAO,YAAamB,EAAM,CAC7B,IAAMC,EAAQF,EAAa,EAC3B,GAAIE,EACA,MAAMA,EACV,IAAIC,EAAOF,EAAK,CAAC,EAEbE,EAAK,SACLA,EAAOA,EAAK,QAChBN,EAAQ,MAAM,YAAY,CAAE,KAAM,OAAQ,KAAMM,CAAK,EAAGA,aAAgB,YAAc,CAACA,CAAI,EAAI,CAAC,CAAC,CACrG,EACArB,EAAO,MAAQ,SAAUY,EAAMC,EAAQ,CACnCE,EAAQ,MAAM,YAAY,CAAE,KAAM,QAAS,UAAWH,EAAM,YAAaC,CAAO,CAAC,CACrF,EACA,OAAO,eAAeb,EAAQ,MAAO,CACjC,IAAK,IAAMV,EAAO,SAAS,EAC3B,aAAc,GACd,WAAY,EAChB,CAAC,EAED,OAAO,eAAeU,EAAQ,WAAY,CACtC,IAFgB,IAAMC,EAGtB,aAAc,GACd,WAAY,EAChB,CAAC,EACMD,CACX,CACA,MAAM,MAAMsB,EAAKC,EAAM,CAGnB,IAAMC,EAAM,IAAIC,EAAQH,EAAKC,CAAI,EAI3BG,EAAeH,GAAM,SAAWC,EAAI,QACpCG,EAAUD,aAAwB,QAClC,OAAO,YAAYA,CAAY,EAC/BA,EACAE,EAAOJ,EAAI,KACbK,EAAO,IAAI,IAAIL,EAAI,GAAG,EAC1B,GAAIK,EAAK,SAAS,WAAW,OAAO,EAAG,CACnC,IAAMC,EAAW,MAAMC,EAAMF,CAAI,EAC3BG,EAAS,IAAIC,EAASH,EAAS,KAAMA,CAAQ,EACnD,OAAAE,EAAO,WAAa,OAAO,YAAYF,EAAS,OAAO,EACvDE,EAAO,YAAcF,EACdE,CACX,CACA,QAASE,EAAI,GAAIA,IAAK,CACd,SAAUP,EACVA,EAAQ,KAAOE,EAAK,KAEpBF,EAAQ,KAAOE,EAAK,KACxB,IAAIM,GAAQ,MAAM,KAAK,OAAO,YAAY,CACtC,KAAM,QACN,MAAO,CACH,OAAQN,EAAK,SAAS,EACtB,OAAQL,EAAI,OACZ,QAASG,EACT,KAAMC,GAAQ,MAClB,CACJ,EAAGA,EAAO,CAACA,CAAI,EAAI,CAAC,CAAC,GAAG,MACpBQ,EAAc,IAAIH,EAASI,GAAY,SAASF,EAAK,MAAM,EAAI,OAAYA,EAAK,KAAM,CACtF,QAAS,IAAI,QAAQA,EAAK,OAAO,EACjC,OAAQA,EAAK,OACb,WAAYA,EAAK,UACrB,CAAC,EACDC,EAAY,WAAaD,EAAK,QAC9BC,EAAY,YAAc,IAAIH,EAASE,EAAK,IAAI,EAChDC,EAAY,SAAWP,EAAK,SAAS,EACrC,IAAMS,EAAWf,GAAM,UAAYC,EAAI,SACvC,GAAIe,GAAe,SAASH,EAAY,MAAM,EAC1C,OAAQE,EAAU,CACd,IAAK,SAAU,CACX,IAAME,EAAWJ,EAAY,QAAQ,IAAI,UAAU,EACnD,GAAI,GAAeF,GAAKM,IAAa,KAAM,CACvCX,EAAO,IAAI,IAAIW,EAAUX,CAAI,EAC7B,QACJ,KAEI,OAAM,IAAI,UAAU,iBAAiB,CAC7C,CACA,IAAK,QACD,MAAM,IAAI,UAAU,iBAAiB,EACzC,IAAK,SACD,OAAOO,CACf,KAGA,QAAOA,CAEf,CACJ,CACJ,EClbA,IAAMK,GAAS,IAAIC,EACbC,GAAgB,WAAW,UAEjC,WAAW,UAAY,IAAI,MAAM,WAAW,UAAW,CACrD,UAAUC,EAASC,EAAM,CACvB,OAAI,KAAK,eAAe,QAAU,IAChC,KAAK,QAAQ,KAAK,IAChB,yBAAyBA,EAAK,CAAC,CAAC,cAAc,KAAK,QAAQ,KAAK,aAAa,EAAE,MAAM,GACrF,MACF,EAEKJ,GAAO,gBACZI,EAAK,CAAC,EACNA,EAAK,CAAC,EACNF,GACA,CACE,aAAc,UAAU,UACxB,OAAQ,KAAK,UAAU,MACzB,EACA,YAAY,SACd,CACF,CACF,CAAC,ECpBD,OAAO,iBAAiB,OAAO,UAAW,CAAC,CAAC,EAExC,eAAgB,WAAW,YAC7B,WAAW,UAAU,WAAaG,EAChC,WAAW,UAAU,WACpBC,IACCA,EAAK,CAAC,EAAIC,EAAmBD,EAAK,CAAC,CAAC,EAC7BA,EAEX,GAGE,cAAe,WAAW,YAE5B,WAAW,UAAU,UAAYD,EAE/B,WAAW,UAAU,UACpBC,IACCA,EAAK,CAAC,EACCA,EAEX,GAGE,gBAAiB,WAAW,YAE9B,WAAW,UAAU,YAAcD,EAEjC,WAAW,UAAU,YACpBC,IACC,KAAK,QAAQ,KAAK,IAAI,wBAAwBA,CAAI,GAAI,MAAM,EACrDA,EAEX,GCpCF,IAAME,EAAiB,UAEvB,SAASC,EAAmBC,EAAkB,CAC5C,IAAMC,EAAe,IACnB,OAAO,KAAKD,CAAO,EAAE,OAAQE,GAC3BA,EAAI,WAAWJ,EAAiB,OAAO,UAAU,IAAI,CACvD,EAEF,OAAO,IAAI,MAAME,EAAS,CACxB,IAAIG,EAAQD,EAAK,CACf,OAAQA,EAAK,CACX,IAAK,UACH,MAAO,CAACA,EAAaE,IACnBD,EAAO,QACL,GAAGL,CAAc,GAAG,OAAO,UAAU,IAAI,IAAII,CAAG,GAChDE,CACF,EAEJ,IAAK,UACH,OAAQF,GACNC,EAAO,QAAQ,GAAGL,CAAc,GAAG,OAAO,UAAU,IAAI,IAAII,CAAG,EAAE,EAErE,IAAK,aACH,OAAQA,GACNC,EAAO,WACL,GAAGL,CAAc,GAAG,OAAO,UAAU,IAAI,IAAII,CAAG,EAClD,EAEJ,IAAK,QACH,MAAO,IAAM,CACX,QAAWA,KAAOD,EAAa,EAC7BE,EAAO,WAAWD,CAAG,CAEzB,EAEF,IAAK,SACH,OAAOD,EAAa,EAAE,OAExB,IAAK,MACH,OAAQI,GAAkBF,EAAOF,EAAa,EAAEI,CAAK,CAAC,CAC1D,CACF,CACF,CAAC,CACH,CAEA,IAAMC,GAAKP,EAAmB,OAAO,YAAY,EAC3CQ,GAAKR,EAAmB,OAAO,cAAc,EAEnD,OAAO,OAAO,aAEd,OAAO,OAAO,eAEd,OAAO,aAAeO,GACtB,OAAO,eAAiBC,GC1BxB,QAAWC,KAAU,KAAK,QAAQ,OAAO,QACnCA,EAAO,OAAO,KAAK,OAAO,UAAU,IAAI,GACtC,iBAAkBA,IACpB,KAAK,QAAQ,KAAK,IAAI,4BAA4BA,EAAO,IAAI,GAAI,MAAM,EACvEA,EAAO,aAAa,MAAM",
  "names": ["rewriteSrcset", "srcset", "origin", "set", "url", "index", "patchFunction", "target", "proxy", "thisArg", "argArray", "proxiedArgs", "patchConstructor", "newTarget", "urlAttributes", "cspAttrs", "attr", "elms", "elm", "descriptors", "value", "innerHTMLDescriptor", "srcSetDescriptor", "rewriteSrcset", "patchFunction", "urlProps", "patchFunction", "prop", "value", "rest", "value", "url", "tobeDeleted", "directRewrites", "rewriteHeaders", "headers", "origin", "HeadersInstance", "newHeaders", "key", "value", "header", "match", "rewriteStringOrUrl", "input", "origin", "OldHeaders", "patchFunction", "args", "request", "rewriteStringOrUrl", "patchConstructor", "arg", "rewriteHeaders", "patchConstructor", "args", "rewriteStringOrUrl", "patchFunction", "target", "thisArg", "type", "func", "args", "patchFunction", "event", "rwFun", "state", "url", "rewriteStringOrUrl", "patchFunction", "fetch", "WebSocket", "Request", "Response", "SharedWorker", "localStorage", "serviceWorker", "WebSocketFields", "searchForPort", "promises", "x", "port", "tryGetPort", "testPort", "promise", "_", "reject", "err", "client", "channel", "resolve", "event", "pingChannel", "pingPromise", "createPort", "path", "registerHandlers", "worker", "newWorker", "WorkerConnection", "worker", "workerPath", "inInit", "searchForPort", "event", "SharedWorker", "createPort", "localStorage", "path", "message", "transferable", "testPort", "channel", "toTransfer", "promise", "resolve", "reject", "validChars", "validProtocol", "protocol", "i", "char", "wsProtocols", "statusEmpty", "statusRedirect", "BareClient", "worker", "WorkerConnection", "remote", "protocols", "webSocketImpl", "requestHeaders", "arrayBufferImpl", "wsProtocols", "proto", "validProtocol", "wsImpl", "WebSocket", "socket", "fakeProtocol", "fakeReadyState", "WebSocketFields", "initialErrorHappened", "e", "initialCloseHappened", "onopen", "protocol", "onmessage", "payload", "onclose", "code", "reason", "onerror", "channel", "event", "getReadyState", "getSendError", "args", "error", "data", "url", "init", "req", "Request", "inputHeaders", "headers", "body", "urlO", "response", "fetch", "result", "Response", "i", "resp", "responseobj", "statusEmpty", "redirect", "statusRedirect", "location", "client", "BareClient", "RealWebSocket", "_target", "args", "patchFunction", "args", "rewriteStringOrUrl", "STORAGE_PREFIX", "createStorageProxy", "storage", "filterBySite", "key", "target", "value", "index", "ls", "ss", "plugin"]
}
