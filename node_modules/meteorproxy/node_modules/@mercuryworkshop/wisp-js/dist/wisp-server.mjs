var t={d:(e,s)=>{for(var i in s)t.o(s,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:s[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.d(e,{logging:()=>s,packet:()=>i,server:()=>a});var s={};t.r(s),t.d(s,{DEBUG:()=>n,ERROR:()=>c,INFO:()=>o,NONE:()=>l,WARN:()=>r,debug:()=>_,error:()=>y,get_timestamp:()=>u,info:()=>d,log:()=>w,log_level:()=>h,set_level:()=>p,warn:()=>f});var i={};t.r(i),t.d(i,{ClosePayload:()=>T,ConnectPayload:()=>$,ContinuePayload:()=>U,DataPayload:()=>P,WispBuffer:()=>v,WispPacket:()=>z,close_reasons:()=>N,packet_classes:()=>C,packet_types:()=>S,stream_types:()=>q});var a={};t.r(a),t.d(a,{ServerConnection:()=>X,ServerStream:()=>Q,options:()=>O,routeRequest:()=>tt});const n=0,o=1,r=2,c=3,l=4;let h=o;function u(){let[t,e]=(new Date).toJSON().split("T");return t=t.replaceAll("-","/"),e=e.split(".")[0],`[${t} - ${e}]`}function p(t){h=t}function _(...t){h>n||console.debug(u()+" debug:",...t)}function d(...t){h>o||console.info(u()+" info:",...t)}function w(...t){h>o||console.log(u()+" log:",...t)}function f(...t){h>r||console.warn(u()+" warn:",...t)}function y(...t){h>c||console.error(u()+" error:",...t)}const m=new TextEncoder,k=m.encode.bind(m),b=new TextDecoder,g=b.decode.bind(b);class v{constructor(t){if(t instanceof Uint8Array)this.from_array(t);else if("number"==typeof t)this.from_array(new Uint8Array(t));else{if("string"!=typeof t)throw console.trace(),"invalid data type passed to wisp buffer constructor";this.from_array(k(t))}}from_array(t){this.size=t.length,this.bytes=t,this.view=new DataView(t.buffer)}concat(t){let e=new v(this.size+t.size);return e.bytes.set(this.bytes,0),e.bytes.set(t.bytes,this.size),e}slice(t,e){let s=this.bytes.slice(t,e);return new v(s)}}class z{static min_size=5;constructor({type:t,stream_id:e,payload:s,payload_bytes:i}){this.type=t,this.stream_id=e,this.payload_bytes=i,this.payload=s}static parse(t){return new z({type:t.view.getUint8(0),stream_id:t.view.getUint32(1,!0),payload_bytes:t.slice(5)})}static parse_all(t){if(t.size<z.min_size)throw"packet too small";let e=z.parse(t),s=C[e.type];if(void 0===s)throw"invalid packet type";if(e.payload_bytes.size<s.size)throw"payload too small";return e.payload=s.parse(e.payload_bytes),e}serialize(){let t=new v(5);return t.view.setUint8(0,this.type),t.view.setUint32(1,this.stream_id,!0),t=t.concat(this.payload.serialize()),t}}class ${static min_size=3;static type=1;static name="CONNECT";constructor({stream_type:t,port:e,hostname:s}){this.stream_type=t,this.port=e,this.hostname=s}static parse(t){return new $({stream_type:t.view.getUint8(0),port:t.view.getUint16(1,!0),hostname:g(t.slice(3).bytes)})}serialize(){let t=new v(3);return t.view.setUint8(0,this.stream_type),t.view.setUint16(1,this.port,!0),t=t.concat(new v(this.hostname)),t}}class P{static min_size=0;static type=2;static name="DATA";constructor({data:t}){this.data=t}static parse(t){return new P({data:t})}serialize(){return this.data}}class U{static type=3;static name="CONTINUE";constructor({buffer_remaining:t}){this.buffer_remaining=t}static parse(t){return new U({buffer_remaining:t.view.getUint32(0,!0)})}serialize(){let t=new v(4);return t.view.setUint32(0,this.buffer_remaining,!0),t}}class T{static min_size=1;static type=4;static name="CLOSE";constructor({reason:t}){this.reason=t}static parse(t){return new T({reason:t.view.getUint8(0)})}serialize(){let t=new v(1);return t.view.setUint8(0,this.buffer_remaining),t}}const C=[void 0,$,P,U,T],S={CONNECT:1,DATA:2,CONTINUE:3,CLOSE:4},q={TCP:1,UDP:2},N={Unknown:1,Voluntary:2,NetworkError:3,InvalidInfo:65,UnreachableHost:66,NoResponse:67,ConnRefused:68,TransferTimeout:71,HostBlocked:72,ConnThrottled:73,ClientError:129},O={hostname_blacklist:null,hostname_whitelist:null,port_blacklist:null,port_whitelist:null,allow_direct_ip:!0,allow_private_ips:!1,allow_loopback_ips:!1,client_ip_blacklist:null,client_ip_whitelist:null,stream_limit_per_host:-1,stream_limit_total:-1,allow_udp_streams:!0,allow_tcp_streams:!0};class D extends Error{}function E(t,e){return t===e||t[0]<=e&&t[1]>=e}function A(t,e){let s=!1;for(let i of t)if(e(i)){s=!0;break}return!s}function I(t,e){for(let s of t)if(e(s))return!0;return!1}function x(t,e,s,i){if(!O.allow_tcp_streams&&e===stream_types.TCP)return N.HostBlocked;if(!O.allow_udp_streams&&e===stream_types.UDP)return N.HostBlocked;if(O.hostname_whitelist){if(A(O.hostname_whitelist,(t=>t.test(s))))return N.HostBlocked}else if(O.hostname_blacklist&&I(O.hostname_blacklist,(t=>t.test(s))))return N.HostBlocked;if(O.port_whitelist){if(A(O.port_whitelist,(t=>E(t,i))))return N.HostBlocked}else if(O.port_blacklist&&I(O.port_blacklist,(t=>E(t,i))))return N.HostBlocked;if(!t)return 0;if(-1!==O.stream_limit_total&&Object.keys(t.streams).length>=O.stream_limit_total)return N.ConnThrottled;if(-1!==O.stream_limit_per_host){let e=0;for(let i of t.streams)i.socket.hostname===s&&e++;if(e>=O.stream_limit_per_host)return N.ConnThrottled}return 0}const B=globalThis.WebSocket,H=globalThis.crypto,R=null,j=null,W=null;class M{send_buffer_size=33554432;constructor(t){this.ws=t,this.connected=!1,this.data_queue=new V(1)}async connect(){await new Promise(((t,e)=>{this.ws.onopen=()=>{this.connected=!0,t()},this.ws.onmessage=t=>{this.data_queue.put(t.data)},this.ws.onclose=()=>{this.connected?this.data_queue.close():e()},this.ws.readyState===this.ws.OPEN&&(this.connected=!0,t())}))}async recv(){return await this.data_queue.get()}async send(t){if(this.ws.send(t),!(this.ws.bufferedAmount<=this.send_buffer_size))for(;!(this.ws.bufferedAmount<=this.send_buffer_size/2);)await new Promise((t=>{setTimeout(t,10)}))}close(t,e){this.ws.close(t,e),this.data_queue.close()}get buffered_amount(){return this.ws.bufferedAmount}}class V{constructor(t){this.max_size=t,this.queue=[],this.put_callbacks=[],this.get_callbacks=[]}put_now(t){this.queue.push(t),this.get_callbacks.shift()?.()}async put(t){this.size<=this.max_size||await new Promise((t=>{this.put_callbacks.push(t)})),this.put_now(t)}get_now(){return this.put_callbacks.shift()?.(),this.queue.shift()}async get(){return this.size>0||await new Promise((t=>{this.get_callbacks.push(t)})),this.get_now()}close(){let t;for(this.queue=[];t=this.get_callbacks.shift();)t();for(;t=this.put_callbacks.shift();)t()}get size(){return this.queue.length}}const L="undefined"!=typeof process;function F(){if(!L)throw"not running on node.js"}async function G(t){let e=R.isIP(t);return 4===e||6===e?t:(await j.lookup(t)).address}class J{constructor(t,e){F(),this.hostname=t,this.port=e,this.recv_buffer_size=128,this.socket=null,this.paused=!1,this.connected=!1,this.data_queue=new V(this.recv_buffer_size)}async connect(){let t=await G(this.hostname);await new Promise(((e,s)=>{this.socket=new R.Socket,this.socket.setNoDelay(!0),this.socket.on("connect",(()=>{this.connected=!0,e()})),this.socket.on("data",(t=>{this.data_queue.put(t)})),this.socket.on("close",(t=>{t&&!this.connected?s():this.data_queue.close(),this.socket=null})),this.socket.on("error",(t=>{f(`tcp stream to ${this.hostname} ended with error - ${t}`)})),this.socket.on("end",(()=>{this.socket&&(this.socket.destroy(),this.socket=null)})),this.socket.connect({host:t,port:this.port})}))}async recv(){return await this.data_queue.get()}async send(t){await new Promise((e=>{this.socket.write(t,e)}))}async close(){this.socket&&(this.socket.end(),this.socket=null)}pause(){this.data_queue.size>=this.data_queue.max_size&&(this.socket.pause(),this.paused=!0)}resume(){this.socket&&this.paused&&(this.socket.resume(),this.paused=!1)}}class K{constructor(t,e){F(),this.hostname=t,this.port=e,this.connected=!1,this.recv_buffer_size=128,this.data_queue=new V(this.recv_buffer_size)}async connect(){let t=await G(this.hostname),e=R.isIP(t);await new Promise(((s,i)=>{this.socket=null.createSocket(6===e?"udp6":"udp4"),this.socket.on("connect",(()=>{s()})),this.socket.on("message",(t=>{this.data_queue.put(t)})),this.socket.on("error",(()=>{this.connected||i(),this.data_queue.close(),this.socket=null})),this.socket.connect(this.port,t)}))}async recv(){return await this.data_queue.get()}async send(t){this.socket.send(t)}async close(){this.socket&&(this.socket.close(),this.socket=null)}pause(){}resume(){}}class Q{static buffer_size=128;constructor(t,e,s){this.stream_id=t,this.conn=e,this.socket=s,this.send_buffer=new V(Q.buffer_size),this.packets_sent=0}async setup(){await this.socket.connect(),this.tcp_to_ws().catch((t=>{y(`(${this.conn.conn_id}) a tcp/udp to ws task encountered an error - ${t}`),this.close()})),this.ws_to_tcp().catch((t=>{y(`(${this.conn.conn_id}) a ws to tcp/udp task encountered an error - ${t}`),this.close()}))}async tcp_to_ws(){for(;;){let t=await this.socket.recv();if(null==t)break;this.socket.pause();let e=new z({type:P.type,stream_id:this.stream_id,payload:new P({data:new v(new Uint8Array(t))})});await this.conn.ws.send(e.serialize().bytes),this.socket.resume()}await this.conn.close_stream(this.stream_id,N.Voluntary)}async ws_to_tcp(){for(;;){let t=await this.send_buffer.get();if(null==t)break;if(await this.socket.send(t),this.packets_sent++,this.packets_sent%(Q.buffer_size/2)!=0)continue;let e=new z({type:U.type,stream_id:this.stream_id,payload:new U({buffer_remaining:Q.buffer_size-this.send_buffer.size})});this.conn.ws.send(e.serialize().bytes)}await this.close()}async close(t=null){if(this.send_buffer.close(),this.socket.close(),null==t)return;let e=new z({type:T.type,stream_id:this.stream_id,payload:new T({reason:t})});await this.conn.ws.send(e.serialize().bytes)}async put_data(t){await this.send_buffer.put(t)}}class X{constructor(t,e,{TCPSocket:s,UDPSocket:i,ping_interval:a}={}){this.ws=new M(t),this.path=e,this.TCPSocket=s||J,this.UDPSocket=i||K,this.ping_interval=a||30,this.ping_task=null,this.streams={},this.conn_id=H.randomUUID().split("-")[0]}async setup(){d(`setting up new wisp connection with id ${this.conn_id}`),await this.ws.connect();let t=new z({type:U.type,stream_id:0,payload:new U({buffer_remaining:Q.buffer_size})});await this.ws.send(t.serialize().bytes),"function"==typeof this.ws.ws.ping&&(this.ping_task=setInterval((()=>{_(`(${this.conn_id}) sending websocket ping`),this.ws.ws.ping()}),1e3*this.ping_interval))}async create_stream(t,e,s,i){let a=x(this,e,s,i);if(a){f(`(${this.conn_id}) refusing to create a stream to ${s}:${i}`);let e=new z({type:T.type,stream_id:t,payload:new T({reason:a})});return void await this.ws.send(e.serialize().bytes)}let n=new(e===q.TCP?this.TCPSocket:this.UDPSocket)(s,i),o=new Q(t,this,n);this.streams[t]=o,o.setup().catch((e=>{f(`(${this.conn_id}) creating a stream to ${s}:${i} failed - ${e}`),this.close_stream(t,N.NetworkError)}))}async close_stream(t,e=null){let s=this.streams[t];null!=s&&(e&&d(`(${this.conn_id}) closing stream to ${s.socket.hostname} for reason ${e}`),await s.close(e),delete this.streams[t])}async route_packet(t){let e=z.parse_all(t),s=this.streams[e.stream_id];if(null!=s||e.type!=P.type)if(e.type===$.type){let t=e.payload.stream_type===q.TCP?"TCP":"UDP";d(`(${this.conn_id}) opening new ${t} stream to ${e.payload.hostname}:${e.payload.port}`),await this.create_stream(e.stream_id,e.payload.stream_type,e.payload.hostname,e.payload.port)}else e.type===P.type?s.put_data(e.payload.data.bytes):e.type==U.type?f(`(${this.conn_id}) client sent a CONTINUE packet, this should never be possible`):e.type==T.type&&await this.close_stream(e.stream_id,e.reason);else f(`(${this.conn_id}) received a DATA packet for a stream which doesn't exist`)}async run(){for(;;){let t;if(t=await this.ws.recv(),null==t)break;try{this.route_packet(new v(new Uint8Array(t)))}catch(t){f(`(${this.conn_id}) routing a packet failed - ${t}`)}}for(let t of Object.keys(this.streams))await this.close_stream(t);clearInterval(this.ping_task),d(`(${this.conn_id}) wisp connection closed`)}}class Y{constructor(t,e){let[s,i]=e.split("/").pop().split(":");if(this.hostname=s,this.port=parseInt(i),0!==x(null,q.TCP,this.hostname,this.port))throw d(`Refusing to create a wsproxy connection to ${this.hostname}:${this.port}`),new D;this.socket=new J(s,i),this.ws=new M(t)}async setup(){await this.ws.connect(),await this.socket.connect(),this.tcp_to_ws().catch((t=>{y(`a tcp to ws task (wsproxy) encountered an error - ${t}`)})),this.ws_to_tcp().catch((t=>{y(`a ws to tcp task (wsproxy) encountered an error - ${t}`)}))}async tcp_to_ws(){for(;;){let t=await this.socket.recv();if(null==t)break;this.socket.pause(),await this.ws.send(t),this.socket.resume()}await this.ws.close()}async ws_to_tcp(){for(;;){let t;if(t=await this.ws.recv(),null==t)break;await this.socket.send(t)}await this.socket.close()}}let Z=null;function tt(t,e,s,i={}){F(),t instanceof W.IncomingMessage?Z.handleUpgrade(t,e,s,(e=>{et(e,t.url,t,i)})):t instanceof B&&et(ws,"/",{})}async function et(t,e,s,i){d(`new connection on ${e} from ${s.socket.address().address}`);try{if(e.endsWith("/")){let s=new X(t,e,i);await s.setup(),await s.run()}else{let s=new Y(t,e,i);await s.setup()}}catch(e){if(t.close(),e instanceof D)return;y("Uncaught server error:\n"+e.stack)}}L&&(Z=new null({noServer:!0}));var st=e.logging,it=e.packet,at=e.server;export{st as logging,it as packet,at as server};